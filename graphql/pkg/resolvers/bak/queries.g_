package resolvers

import (
	"context"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/MemeLabs/Rustla2/graphql/api/gql"
	"github.com/vektah/gqlparser/ast"
)

type queryResolver struct{ *Resolver }

func (r *queryResolver) Viewer(ctx context.Context) (*gql.User, error) {
	panic("not implemented")

	// reqCtx := graphql.GetRequestContext(ctx)
	// fieldSelections := graphql.GetResolverContext(ctx).Field.Selections

	// // spew.Dump(map[string]interface{}{
	// // 	"reqCtx":          reqCtx,
	// // 	"fieldSelections": fieldSelections,
	// // })

	// var sels []string

	// for _, sel := range fieldSelections {
	// 	switch sel := sel.(type) {
	// 	case *ast.Field:
	// 		sels = append(sels, fmt.Sprintf("%s as %s", sel.Name, sel.Alias))
	// 	case *ast.InlineFragment:
	// 		sels = append(sels, fmt.Sprintf("inline fragment on %s", sel.TypeCondition))
	// 	case *ast.FragmentSpread:
	// 		fragment := reqCtx.Doc.Fragments.ForName(sel.Name)
	// 		sels = append(sels, fmt.Sprintf("named fragment %s on %s", sel.Name, fragment.TypeCondition))
	// 	}
	// }

	// spew.Dump(sels)

	// // spew.Dump(ctx)
	// return &gql.User{}, nil
}

func (r *queryResolver) Channels(ctx context.Context) ([]gql.Channel, error) {
	reqCtx := graphql.GetRequestContext(ctx)
	fieldSelections := graphql.GetResolverContext(ctx).Field.Selections

	var sels []string
	for _, sel := range fieldSelections {
		switch sel := sel.(type) {
		case *ast.Field:
			sels = append(sels, fmt.Sprintf("%s as %s", sel.Name, sel.Alias))
		case *ast.InlineFragment:
			sels = append(sels, fmt.Sprintf("inline fragment on %s", sel.TypeCondition))
		case *ast.FragmentSpread:
			fragment := reqCtx.Doc.Fragments.ForName(sel.Name)
			sels = append(sels, fmt.Sprintf("named fragment %s on %s", sel.Name, fragment.TypeCondition))
		}
	}

	return nil, nil
}
